* オブジェクト再指向：ジェネリック関数
Lispの発明はオブジェクト指向プログラミングの台頭よりも数十年早かったため、新しいLisper（Lispユーザー）はCommon Lispが非常にオブジェクト指向的な言語であることに驚くことがあります。Common Lispの直近の前身は、オブジェクト指向が新しくエキサイティングなアイデアであった時代に開発され、特にSmalltalkに見られるようなオブジェクト指向のアイデアをLispに取り込むためのさまざまな試みが行われました。Common Lispの標準化の一環として、これらの試みのいくつかが「Common Lisp Object System（CLOS）」という名の下に統合されました。ANSI標準はCLOSを言語に組み込み、CLOSを独立したものとして話すことはもはや意味を成しません。

CLOSがCommon Lispに提供した機能は、避けられないものから、Lispの「言語を構築するためのツール」という哲学の一風変わった表現まで幅広くあります。これらの機能すべてを完全にカバーすることはこの本の範囲を超えますが、この章と次の章で、基本的な機能を説明し、Common Lispのオブジェクトに対するアプローチの概要をお伝えします。

まず、Common Lispのオブジェクトシステムは、他の多くの言語と比較して、オブジェクト指向の原則をかなり異なる形で具現化していることを留意してください。オブジェクト指向の基本的なアイデアを深く理解しているなら、Common Lispがそのアイデアを特に強力で一般的な方法で表現していることを評価できるでしょう。しかし、もしオブジェクト指向に関して特定の言語にしか経験がない場合は、Common Lispのアプローチがやや異質に感じるかもしれません。その場合、一つの言語だけがオブジェクト指向をサポートする方法だと決めつけないようにしましょう。オブジェクト指向プログラミングの経験がほとんどない場合でも、ここでの説明を理解するのに問題はないはずです。他の言語との比較に惑わされないようにすると良いでしょう。

** ジェネリック関数とクラス
オブジェクト指向の基本的なアイデアは、プログラムを整理する強力な方法として、データ型を定義し、そのデータ型に操作を関連付けるというものです。特に、操作を呼び出したときに、その操作が適用されるオブジェクトの型によって正確な動作が決まるようにしたいのです。オブジェクト指向に関する入門書でよく使われる古典的な例として、さまざまな幾何学的図形を表すオブジェクトに対して適用できる操作「draw」があります。円や三角形、四角形を描画するための異なる実装を提供でき、drawの呼び出しは、その操作が適用されるオブジェクトの型に応じて実際に円、三角形、または四角形を描画することになります。drawの異なる実装は別々に定義され、他のdrawの実装や呼び出し側のコードを変更することなく、新しい図形を描画するためのバージョンを追加できます。このオブジェクト指向の特徴は、ギリシャ語で「多くの形」を意味する「ポリモーフィズム（多相性）」と呼ばれます。これは、1つの概念的な操作（例えばオブジェクトの描画）が、さまざまな具体的な形を取ることができるからです。

Common Lispは、今日のほとんどのオブジェクト指向言語と同様に、クラスベースです。すべてのオブジェクトは特定のクラスのインスタンスです。オブジェクトのクラスはその表現を決定します。NUMBERやSTRINGといった組み込みクラスは、不透明な表現を持ち、それらの型を操作するための標準関数を介してのみアクセス可能です。ユーザー定義クラスのインスタンスは、次章で説明するように、スロットと呼ばれる名前付きの部分から構成されます。

クラスは階層的に配置されており、すべてのオブジェクトに対する分類法を形成しています。クラスは他のクラスのサブクラスとして定義され、そのクラスのスーパークラスと呼ばれます。クラスはその定義の一部をスーパークラスから継承し、クラスのインスタンスはスーパークラスのインスタンスとしても扱われます。Common Lispでは、クラスの階層は単一のルート、すなわちクラスTに集約され、Tはすべての他のクラスの直接または間接的なスーパークラスです。したがって、Common LispのすべてのデータはTのインスタンスです。また、Common Lispは多重継承をサポートしており、1つのクラスが複数の直接のスーパークラスを持つことができます。

Lisp以外では、ほとんどすべてのオブジェクト指向言語が、Simulaによって確立された基本パターンに従い、クラスに関連付けられたメソッドやメンバ関数を使用しています。これらの言語では、特定のオブジェクトに対してメソッドが呼び出され、そのオブジェクトのクラスが実行されるコードを決定します。このメソッド呼び出しのモデルはSmalltalkの用語に従い、「メッセージパッシング」と呼ばれます。概念的には、メッセージパッシングシステムにおけるメソッド呼び出しは、実行するメソッドの名前と引数を含むメッセージを、そのメソッドが呼び出されるオブジェクトに送信することから始まります。オブジェクトは、そのクラスを使用してメッセージ内の名前に関連付けられたメソッドを検索し、それを実行します。各クラスは、特定の名前に対して独自のメソッドを持つことができるため、同じメッセージを異なるオブジェクトに送信すると、異なるメソッドが呼び出される可能性があります。

初期のLispオブジェクトシステムも似たような動作をしており、特定のオブジェクトにメッセージを送信するためにSENDという特別な関数を提供していました。しかし、この方法は完全には満足できるものではありませんでした。メソッド呼び出しが通常の関数呼び出しと異なるものになってしまったからです。構文的には、メソッド呼び出しは次のように記述されます。

#+begin_src lisp
  (send object 'foo)  
#+end_src

これに対して通常の関数呼び出しは次のようになります。

#+begin_src lisp
  (foo object)
#+end_src

さらに重要なのは、メソッドが関数ではなかったため、高階関数（例えばMAPCAR）の引数として渡すことができなかった点です。リストのすべての要素に対してMAPCARを使用してメソッドを呼び出したい場合、次のように書かなければなりませんでした。

#+begin_src lisp
  (mapcar #'(lambda (object) (send object 'foo)) objects)
#+end_src

これに対して、通常の関数呼び出しであれば次のように書けるはずです。

#+begin_src lisp
  (mapcar #'foo objects)
#+end_src

最終的に、Lispオブジェクトシステムを開発していた人々は、メソッドと関数を統合し、ジェネリック関数と呼ばれる新しい種類の関数を作り出しました。これにより、上記の問題が解決されただけでなく、メッセージパッシングのオブジェクトシステムでは意味をなさない多くの機能をオブジェクトシステムに導入することができました。

ジェネリック関数はCommon Lispのオブジェクトシステムの中心であり、この章の残りで取り扱うテーマです。クラスについても少し触れざるを得ませんが、ここではジェネリック関数の定義と使用に焦点を当てます。次章では、自分自身のクラスを定義する方法を紹介します。

** ジェネリック関数とメソッド
ジェネリック関数は抽象的な操作を定義し、その名前とパラメータリストを指定しますが、実装は提供しません。例えば、画面にさまざまな形を描画するために使うジェネリック関数 `draw` を次のように定義することができます。

#+begin_src lisp
  (defgeneric draw (shape)
    (:documentation "Draw the given shape on the screen."))
#+end_src

ここでは `DEFGENERIC` の構文について次のセクションで説明しますが、今のところこの定義には実際のコードが含まれていないことに注目してください。

ジェネリック関数は理論的にはどんなオブジェクトも引数として受け入れられるため、「ジェネリック」と呼ばれています。しかし、それ自体では何も実行できません。ジェネリック関数だけを定義しても、どんな引数で呼び出してもエラーが発生します。ジェネリック関数の実際の実装は、メソッドによって提供されます。各メソッドは特定のクラスの引数に対してジェネリック関数の実装を提供します。ジェネリック関数ベースのシステムとメッセージパッシングシステムの最大の違いは、メソッドがクラスに属さず、ジェネリック関数に属していることです。ジェネリック関数が呼び出された際、どのメソッドを実行するかを決定するのはジェネリック関数の役割です。

メソッドは、ジェネリック関数で定義された必須パラメータを「特化」することで、対応できる引数の種類を示します。例えば、ジェネリック関数 `draw` では、`shape` パラメータをクラス `circle` のインスタンスに特化したメソッドや、クラス `triangle` のインスタンスに特化したメソッドを定義できます。それらのメソッドは次のようになります（描画の実装コードは省略します）。

#+begin_src lisp
  (defmethod draw ((shape circle))
    ...)

  (defmethod draw ((shape triangle))
    ...)
#+end_src

ジェネリック関数が呼び出されると、渡された実際の引数を各メソッドの特化と比較し、適用可能なメソッドを見つけ出します。たとえば、`draw` を呼び出して `circle` のインスタンスを渡すと、`shape` をクラス `circle` に特化したメソッドが適用されます。同様に、`triangle` を渡すと `triangle` に特化したメソッドが適用されます。単純なケースでは1つのメソッドだけが適用可能で、そのメソッドが呼び出しを処理します。しかし、複雑なケースでは複数のメソッドが適用される場合があり、それらは「メソッドの組み合わせ」セクションで説明するように、1つの有効なメソッドとして結合されて呼び出しを処理します。

パラメータを特化する方法は2つあります。通常は、引数が特定のクラスのインスタンスでなければならないことを指定します。クラスのインスタンスは、そのクラスのスーパークラスのインスタンスとしても扱われるため、特定のクラスに特化したパラメータを持つメソッドは、対応する引数がそのクラスやそのサブクラスの直接のインスタンスである場合に適用可能となります。もう一つの特化方法は、特定のオブジェクトに適用されるメソッドを指定する「EQL特化子」と呼ばれるものです。

ジェネリック関数が単一のパラメータに特化したメソッドしか持たず、すべての特化子がクラス特化子である場合、ジェネリック関数の呼び出しの結果は、メッセージパッシングシステムでメソッドを呼び出す結果と非常に似ています。つまり、操作の名前とそれが呼び出されるオブジェクトのクラスの組み合わせが、実行されるメソッドを決定します。

しかし、ルックアップの順序を逆にすることで、メッセージパッシングシステムにはない可能性が開かれます。ジェネリック関数は、複数のパラメータに特化したメソッドをサポートし、複数の継承をより管理しやすくするためのフレームワークを提供し、メソッドがどのように効果的なメソッドに結合されるかを制御するための宣言的な構造を使用できるようにします。これにより、多くの一般的な使用パターンが、煩雑なコードなしにサポートされます。

次に、このジェネリック関数とメソッドを定義するために使用される2つのマクロ `DEFGENERIC` と `DEFMETHOD` の基本について説明します。

** DEFGENERIC

これらのマクロとそれらがサポートする様々な機能を感じてもらうために、銀行アプリケーションの一部として書くかもしれないコードをお見せします。と言っても、これは実際の銀行アプリケーションではなく、いわばおもちゃのような銀行アプリケーションです。このコードのポイントは、いくつかの言語機能を見ることであり、本格的な銀行ソフトウェアの書き方を学ぶことではありません。たとえば、このコードは複数の通貨の問題や、監査証跡やトランザクションの整合性といった問題に対処しようともしていません。

新しいクラスの定義については次の章で説明するので、今は特定のクラスが既に存在していると仮定してください。たとえば、bank-accountクラスがあり、それには二つのサブクラスである checking-account と savings-account が存在するものとします。クラス階層は次のようになっています。

(image)

最初のジェネリック関数は withdraw です。この関数は、指定された金額だけアカウントの残高を減らします。残高が指定された金額より少ない場合は、エラーを発生させ、残高は変更されないままにしておきます。まずは、DEFGENERIC を使ってジェネリック関数を定義します。

DEFGENERIC の基本的な形式は、DEFUN に似ていますが、ボディがないのが特徴です。DEFGENERIC のパラメータリストは、ジェネリック関数に定義されるすべてのメソッドが受け入れなければならないパラメータを指定します。ボディの代わりに、DEFGENERIC には様々なオプションを含めることができます。常に含めるべきオプションの一つは :documentation です。これは、ジェネリック関数の目的を説明する文字列を提供するために使用します。ジェネリック関数は純粋に抽象的なものなので、ユーザーと実装者の両方にその目的を明確にすることが重要です。したがって、withdraw を次のように定義することができます。

#+begin_src lisp
  (defgeneric withdraw (account amount)
    (:documentation "Withdraw the specified amount from the account.
     Signal an error if the current balance is less than amount."))
#+end_src

** DEFMETHOD

次に、DEFMETHODを使って withdraw を実装するメソッドを定義します。

メソッドのパラメータリストは、ジェネリック関数と一致していなければなりません。この場合、withdraw に定義されるすべてのメソッドは、必ず2つの必須パラメータを持つ必要があります。一般的に言えば、メソッドは必須およびオプションパラメータの数が同じであり、ジェネリック関数で指定された &rest や &key パラメータに対応する任意の引数を受け入れることができなければなりません。

すべてのアカウントで基本的な引き出しの仕組みは同じなので、bank-account クラスに基づいてアカウントパラメータを特化させるメソッドを定義できます。関数 balance はアカウントの現在の残高を返すと仮定し、それを SETF および DECF と共に使って残高を設定することができます。関数 ERROR はエラーを発生させるための標準関数であり、これについては第19章で詳しく説明します。これらの2つの関数を使用して、基本的な withdraw メソッドを次のように定義できます。

#+begin_src lisp
  (defmethod withdraw ((account bank-account) amount)
    (when (< (balance account) amount)
      (error "残高不足です。"))
    (decf (balance account) amount))
#+end_src

このコードからわかるように、DEFMETHODの形式はDEFGENERICよりもDEFUNにさらに似ています。唯一の違いは、必要なパラメータを2要素リストに置き換えて特化できることです。最初の要素はパラメータの名前で、2番目の要素は特化子であり、クラスの名前か EQL 特化子のいずれかです。このパラメータ名は何でも構いませんが、ジェネリック関数で使用された名前と一致していることがよくあります。

このメソッドは、withdraw の最初の引数が bank-account のインスタンスである場合に適用されます。2番目のパラメータ amount は暗黙的に T に特化されており、すべてのオブジェクトは T のインスタンスであるため、この特化はメソッドの適用性には影響しません。

次に、すべての当座預金口座にはオーバードラフト保護があると仮定します。つまり、各当座預金口座は別の銀行口座にリンクされており、当座預金口座自体の残高が引き出しをカバーできない場合に、そのリンクされた口座から引き出しが行われます。関数 overdraft-account が checking-account オブジェクトを受け取り、リンクされた口座を表す bank-account オブジェクトを返すと仮定します。

したがって、checking-account オブジェクトからの引き出しには、標準的な bank-account オブジェクトからの引き出しよりもいくつかの追加手順が必要です。まず、引き出す金額が口座の現在の残高を超えているかどうかを確認し、超えている場合はオーバードラフト口座から差額を引き出します。その後、標準的な bank-account オブジェクトと同様に処理を続行します。

そのため、checking-account に特化した withdraw メソッドを定義し、振替を処理してから bank-account に特化したメソッドに制御を渡すことができます。このようなメソッドは次のように見えます。

#+begin_src lisp
  (defmethod withdraw ((account checking-account) amount)
    (let ((overdraft (- amount (balance account))))
      (when (plusp overdraft)
        (withdraw (overdraft-account account) overdraft)
        (incf (balance account) overdraft)))
    (call-next-method))
#+end_src

関数 CALL-NEXT-METHOD は、適用可能なメソッドを組み合わせるために使用されるジェネリック関数の一部です。これは、このメソッドから bank-account に特化したメソッドに制御を渡すことを示します。ここでは引数なしで呼び出されているため、次のメソッドは最初にジェネリック関数に渡された引数で呼び出されます。また、引数付きで呼び出すことも可能で、その場合はその引数が次のメソッドに渡されます。

すべてのメソッドで CALL-NEXT-METHOD を呼び出す必要はありません。しかし、呼び出さない場合は、新しいメソッドがジェネリック関数の望ましい動作を完全に実装する責任を負うことになります。たとえば、bank-account のサブクラスである proxy-account が実際には自分の残高を管理せず、代わりに他の口座に引き出しを委任すると仮定します。この場合、次のようなメソッドを書くことができます（proxied-account 関数が代理口座を返すと仮定します）。

#+begin_src lisp
  (defmethod withdraw ((proxy proxy-account) amount)
    (withdraw (proxied-account proxy) amount))
#+end_src

最後に、DEFMETHOD では EQL 特化子を使用して特定のオブジェクトに特化したメソッドを作成することもできます。たとえば、銀行アプリが非常に腐敗した銀行に展開されると仮定します。変数 *account-of-bank-president* が、銀行の社長の口座を表す特定の銀行口座への参照を保持しているとします。また、変数 *bank* が銀行全体を表し、関数 embezzle が銀行からお金を盗むと仮定します。銀行の社長が、自分の口座に対して特別な処理をするように withdraw を「修正」するよう求めた場合、次のように定義できます。

#+begin_src lisp
  (defmethod withdraw ((account (eql *account-of-bank-president*)) amount)
    (let ((overdraft (- amount (balance account))))
      (when (plusp overdraft)
        (incf (balance account) (embezzle *bank* overdraft)))
    (call-next-method)))
#+end_src

ただし、EQL 特化子のフォームは、特化するオブジェクトを提供するものであり、DEFMETHODが評価されるときに一度だけ評価されます。このメソッドは、定義時の *account-of-bank-president* の値に特化されます。そのため、後で変数を変更しても、メソッドは変更されません。

** メソッドの組み合わせ

メソッドのボディの外では CALL-NEXT-METHOD は意味を持ちません。メソッドの中では、ジェネリック関数の仕組みによって意味が与えられます。これは、ジェネリック関数が呼び出されるたびに、その特定の呼び出しに適用可能なすべてのメソッドを使用して効果的なメソッド（effective method）を構築するためです。この「適用可能なメソッドを組み合わせて効果的なメソッドを作成する」という概念は、ジェネリック関数の中心であり、メッセージパッシングシステムには見られない機能をジェネリック関数がサポートできるようにする要因です。したがって、これが実際にどのように機能しているのかを詳しく見ていく価値があります。特に、メッセージパッシングモデルに強く影響を受けている人々は注意が必要です。なぜなら、ジェネリック関数はメッセージパッシングと比較してメソッドディスパッチングを内側から外側へと逆転させ、クラスではなくジェネリック関数を主役にするからです。

概念的には、効果的なメソッドは3つのステップで構築されます。まず、ジェネリック関数は実際に渡された引数に基づいて適用可能なメソッドのリストを作成します。次に、そのリストをパラメータ特化子の具体性に従って並べ替えます。最後に、並べ替えられたリストから順にメソッドを取り出し、そのコードを組み合わせて効果的なメソッドを生成します。

適用可能なメソッドを見つけるために、ジェネリック関数は実際の引数を各メソッドの対応するパラメータ特化子と比較します。メソッドは、すべての特化子が対応する引数と互換性がある場合にのみ適用可能と見なされます。

特化子がクラス名の場合、引数の実際のクラス名かそのスーパークラスの1つを指している場合に互換性があります（明示的な特化子がないパラメータは暗黙的にクラス T に特化されているため、すべての引数と互換性があります）。一方、EQL 特化子は、引数が特化子で指定されたオブジェクトと同じオブジェクトである場合にのみ互換性があります。

すべての引数が対応する特化子と比較されるため、それらすべてがメソッドの適用性に影響を与えます。複数のパラメータに対して明示的に特化したメソッドはマルチメソッドと呼ばれます。この点については、「マルチメソッド」のセクションで詳しく説明します。

適用可能なメソッドが見つかった後、ジェネリック関数の仕組みは、それらを効果的なメソッドに組み合わせる前に並べ替える必要があります。2つの適用可能なメソッドを並べ替えるために、ジェネリック関数は左から右へとパラメータ特化子を比較します。そして、異なる最初の特化子によってその順序が決まり、より具体的な特化子を持つメソッドが先に来ます。

適用可能なメソッドだけが並べ替えられるため、すべてのクラス特化子は対応する引数の実際のインスタンスとなるクラスを指していることがわかります。通常の場合、2つのクラス特化子が異なる場合、一方が他方のサブクラスであることが多いです。この場合、サブクラスを指す特化子がより具体的と見なされます。これが、checking-account に特化したメソッドが bank-account に特化したメソッドよりも具体的と見なされた理由です。

多重継承は、この具体性の概念をやや複雑にします。なぜなら、実際の引数が2つのクラスのインスタンスであり、そのいずれも他方のサブクラスではない場合があるからです。こうしたクラスがパラメータ特化子として使用されると、ジェネリック関数はサブクラスがスーパークラスよりも具体的であるというルールだけではそれらを並べ替えることができません。この具体性の概念がどのように拡張されて多重継承に対処するのかについては、次章で説明します。現時点では、クラス特化子を並べ替えるための決定論的なアルゴリズムが存在することを理解しておいてください。

最後に、EQL 特化子は常にクラス特化子よりも具体的であり、適用可能なメソッドだけが考慮されるため、特定のパラメータに対して複数のメソッドが EQL 特化子を持っている場合、それらすべてが同じ EQL 特化子を持つ必要があります。それらのメソッドの比較は、他のパラメータに基づいて決定されます。

** 標準メソッドの組み合わせ
適用可能なメソッドが見つかり並べ替えられる仕組みを理解したので、次はその最後のステップ、つまり並べ替えられたメソッドのリストをどのように1つの効果的なメソッドに組み合わせるかを詳しく見ていきましょう。デフォルトでは、ジェネリック関数は「標準メソッドの組み合わせ（standard method combination）」を使用します。標準メソッドの組み合わせでは、すでに見てきた通り、CALL-NEXT-METHOD が機能するようにメソッドが組み合わされます。つまり、最も具体的なメソッドが最初に実行され、各メソッドが次に具体的なメソッドに CALL-NEXT-METHOD を通じて制御を渡すことができます。

しかし、これにはもう少し深い仕組みがあります。これまでに説明してきたメソッドは「プライマリーメソッド」と呼ばれています。名前が示す通り、プライマリーメソッドはジェネリック関数の主要な実装を提供する責任を負います。標準メソッドの組み合わせでは、さらに3種類の補助メソッドもサポートしています。それらは :before、:after、および :around メソッドです。補助メソッドは、メソッドの型を示す「メソッド修飾子（method qualifier）」を、メソッド名とパラメータリストの間に記述することで定義されます。例えば、withdraw に対して bank-account クラスに特化した :before メソッドは次のように始まります。

#+begin_src lisp
  (defmethod withdraw :before ((account bank-account) amount) ...)
#+end_src

補助メソッドの種類ごとに、効果的なメソッドへの組み込み方が異なります。適用可能な :before メソッドはすべて、最も具体的なプライマリーメソッドの前に実行され、最も具体的なものから順に実行されます。これにより、:before メソッドはプライマリーメソッドが実行できるように必要な準備を行うのに役立ちます。例えば、checking-account に特化した :before メソッドを使ってオーバードラフト保護を実装することができます。

#+begin_src lisp
  (defmethod withdraw :before ((account checking-account) amount)
    (let ((overdraft (- amount (balance account))))
      (when (plusp overdraft)
        (withdraw (overdraft-account account) overdraft)
        (incf (balance account) overdraft))))
#+end_src

この :before メソッドには3つの利点があります。1つ目は、メソッドが withdraw 関数の全体的な挙動にどのように影響を与えるかがすぐに明確になる点です。これは主な挙動に干渉することなく、結果も変更しません。

次の利点は、checking-account よりも具体的なクラスに特化したプライマリーメソッドがこの :before メソッドに干渉しないため、checking-account のサブクラスの作成者が withdraw の挙動を拡張しやすくなる点です。

最後に、:before メソッドは CALL-NEXT-METHOD を呼び出して残りのメソッドに制御を渡す必要がないため、その点でバグが発生する心配がないという点も利点です。

他の補助メソッドも、その名前が示す通りの方法で効果的なメソッドに組み込まれます。すべての :after メソッドは、最も具体的なものから最後に実行され、これは :before メソッドの逆順です。したがって、:before メソッドと :after メソッドは、プライマリーメソッドによって提供されるコア機能を包み込むように組み合わされます。具体的な :before メソッドが、一般的な :before メソッドやプライマリーメソッドが正常に実行できるように準備し、具体的な :after メソッドが、すべてのプライマリーメソッドや一般的な :after メソッドの後にクリーンアップを行います。

最後に、:around メソッドはプライマリーメソッドのように組み合わされますが、すべての他のメソッドの「周り」で実行されます。最も具体的な :around メソッドのコードが最初に実行され、CALL-NEXT-METHOD が呼ばれると次に具体的な :around メソッドのコードが実行されます。最も具体的でない :around メソッドでは、:before、プライマリーメソッド、:after メソッドの複合体が呼び出されます。ほとんどの :around メソッドには CALL-NEXT-METHOD を含むことが多いですが、含まない場合、そのメソッドはすべての他のメソッドの実装を完全に乗っ取ります。

このような乗っ取りが必要な場合もありますが、通常 :around メソッドは、他のメソッドが実行される動的なコンテキストを設定するために使用されます。例えば、動的変数を束縛するか、エラーハンドラを設定するために使われます。

** 他のメソッドの組み合わせについて

標準メソッドの組み合わせに加えて、言語には「シンプル組み込みメソッドの組み合わせ（simple built-in method combinations）」として知られる9つの他の組み合わせが定義されています。これらは、比較的シンプルで便利な方法でメソッドを組み合わせることができます。さらに、カスタムメソッドの組み合わせを定義することも可能ですが、それは非常に専門的な機能であり、この本の範囲を超えています。ここでは、シンプル組み込みメソッドの組み合わせの使用方法を簡単に説明し、その可能性についての感覚をお伝えします。

すべてのシンプルな組み合わせは同じパターンに従います。最も具体的なプライマリーメソッドを呼び出し、CALL-NEXT-METHOD で他のメソッドに制御を渡す代わりに、シンプルなメソッドの組み合わせは、すべてのプライマリーメソッドのコードを1つにまとめ、それらを特定の関数、マクロ、または特殊演算子でラップします。この演算子にメソッドの組み合わせの名前がついています。9つの組み合わせはそれぞれ、+、AND、OR、LIST、APPEND、NCONC、MIN、MAX、および PROGN と名付けられています。これらのシンプルな組み合わせは、プライマリーメソッドと :around メソッドの2種類のみをサポートします。:around メソッドは、標準メソッドの組み合わせと同じように動作します。

例えば、+ メソッドの組み合わせを使用するジェネリック関数は、すべてのプライマリーメソッドが返す結果の合計を返します。AND と OR のメソッドの組み合わせは、これらのマクロのショートサーキット動作により、すべてのプライマリーメソッドが必ずしも実行されるわけではないことに注意してください。AND の組み合わせを使用するジェネリック関数は、1つのメソッドが NIL を返すとすぐに終了し、それ以外の場合は最後のメソッドの値を返します。同様に、OR の組み合わせは、最初に NIL 以外の値を返したメソッドの結果を返します。

特定のメソッドの組み合わせを使用するジェネリック関数を定義するには、DEFGENERIC フォームに :method-combination オプションを含めます。このオプションの値には、使用するメソッドの組み合わせの名前を指定します。例えば、個々のメソッドの結果を合計して返す + メソッドの組み合わせを使用するジェネリック関数 priority を定義する場合、次のように書くことができます。

#+begin_src lisp
  (defgeneric priority (job)
    (:documentation "Return the priority at which the job should be run.")
    (:method-combination +))
#+end_src

デフォルトでは、これらのメソッドの組み合わせは、プライマリーメソッドを最も具体的な順に結合します。しかし、DEFGENERIC フォームでメソッドの組み合わせ名の後に :most-specific-last というキーワードを追加することで、順序を逆にすることも可能です。メソッドが副作用を持たない限り、+ の組み合わせを使用する場合、順序はおそらく問題にはならないでしょうが、デモの目的で、次のように priority を最も具体的でない順に実行するように変更することができます。

#+begin_src lisp
  (defgeneric priority (job)
    (:documentation "Return the priority at which the job should be run.")
    (:method-combination + :most-specific-last))
#+end_src

これらの組み合わせを使用するジェネリック関数のプライマリーメソッドは、その組み合わせの名前で修飾されなければなりません。したがって、priority に定義されたプライマリーメソッドは次のようになるかもしれません。

#+begin_src lisp
  (defmethod priority + ((job express-job)) 10)
#+end_src

このようにメソッドの定義を見ると、そのメソッドが特定の種類のジェネリック関数に属していることが明白です。

すべてのシンプルな組み込みメソッドの組み合わせは、標準メソッドの組み合わせと同じように動作する :around メソッドをサポートしています。最も具体的な :around メソッドは他のすべてのメソッドよりも先に実行され、CALL-NEXT-METHOD が使用されて、次に具体的でない :around メソッドへ制御が渡され、最終的にプライマリーメソッドに到達します。:most-specific-last オプションは :around メソッドの順序には影響しません。さらに、組み込みのメソッドの組み合わせは、:before や :after メソッドをサポートしていません。

標準メソッドの組み合わせと同様に、これらの組み合わせも「手作業」で行うことができること以上のことはできませんが、コードをより簡潔で表現力豊かにするために、やりたいことを表現し、言語がすべての処理を自動的に行ってくれます。

とはいえ、99%の場合、標準メソッドの組み合わせがちょうど適しているでしょう。残りの1%のうち、さらに99%は、これらのシンプルな組み込みメソッドの組み合わせのいずれかで対処できます。もし、組み込みの組み合わせがいずれも適さない1%の1%のケースに遭遇した場合、DEFINE-METHOD-COMBINATION を参照するとよいでしょう。

** マルチメソッド

ジェネリック関数の必須パラメータのうち複数に対して明示的に特殊化されたメソッドをマルチメソッドと呼びます。マルチメソッドは、ジェネリック関数とメッセージパッシングが本当に異なる点です。マルチメソッドは特定のクラスに属さないため、メッセージパッシング言語には適合しません。代わりに、各マルチメソッドは、ジェネリック関数が呼び出されたときに、そのメソッドの特殊化されたパラメータ全てと一致する引数が渡される場合に適用されるジェネリック関数の実装の一部を定義します。

#+begin_quote
*** マルチメソッド vs メソッドのオーバーロード

静的型付けされたメッセージパッシング言語（たとえば、JavaやC++）に慣れたプログラマーは、マルチメソッドがこれらの言語でのメソッドオーバーローディングと似ていると考えるかもしれません。しかし、これらの2つの言語機能は実際にはかなり異なります。メソッドオーバーローディングはコンパイル時に引数のコンパイル時型に基づいてメソッドが選択されるのに対し、マルチメソッドはランタイム時に引数の型に基づいてメソッドが選択されます。これを理解するために、次の2つのJavaクラスを見てみましょう：

#+begin_src java
  public class A {
    public void foo(A a) { System.out.println("A/A"); }
    public void foo(B b) { System.out.println("A/B"); }
  }
  public class B extends A {
    public void foo(A a) { System.out.println("B/A"); }
    public void foo(B b) { System.out.println("B/B"); }
  }
#+end_src

次に、このクラスのmainメソッドを実行した場合を考えます。

#+begin_src java
  public class Main {
    public static void main(String[] argv) {
      A obj = argv[0].equals("A") ? new A() : new B();
      obj.foo(obj);
    }
  }
#+end_src

MainにAをインスタンス化するように指示すると、予想通り「A/A」が出力されます。

#+begin_src bash
  $ java com.gigamonkeys.Main A
  A/A
#+end_src

しかし、MainにBをインスタンス化するように指示すると、objの実際の型はディスパッチの半分だけが考慮されます。

#+begin_src bash
  $ java com.gigamonkeys.Main B
  B/A
#+end_src

もしオーバーロードされたメソッドがCommon Lispのマルチメソッドのように機能していたなら、ここで「B/B」が出力されるはずです。メッセージパッシング言語で複数ディスパッチを手動で実装することは可能ですが、複数ディスパッチのコードは特定のクラスに属しないため、メッセージパッシングモデルの考え方に反します。
#+end_quote

マルチメソッドは、メッセージパッシング言語で特定の振る舞いをどのクラスに属させるべきか決定に苦しむような状況に最適です。たとえば、ドラムがドラムスティックで叩かれたときの音は、どのようなドラムであるか、またはどのようなスティックで叩くかによるものです。もちろん、どちらも関係しています。この状況をCommon Lispでモデル化するには、2つの引数を取るジェネリック関数 beat を定義します。

#+begin_src lisp
  (defgeneric beat (drum stick)
    (:documentation
     "Produce a sound by hitting the given drum with the given stick."))
#+end_src

次に、関心のある組み合わせに対して beat を実装するさまざまなマルチメソッドを定義できます。たとえば：

#+begin_src lisp
  (defmethod beat ((drum snare-drum) (stick wooden-drumstick)) ...)
  (defmethod beat ((drum snare-drum) (stick brush)) ...)
  (defmethod beat ((drum snare-drum) (stick soft-mallet)) ...)
  (defmethod beat ((drum tom-tom) (stick wooden-drumstick)) ...)
  (defmethod beat ((drum tom-tom) (stick brush)) ...)
  (defmethod beat ((drum tom-tom) (stick soft-mallet)) ...)
#+end_src

マルチメソッドは組み合わせ爆発の問題を解決するものではありません。たとえば、5種類のドラムと6種類のスティックがあり、すべての組み合わせが異なる音を出す場合、30個の異なるメソッドが必要です。マルチメソッドが助けてくれるのは、単一の引数に特化したメソッドで役立つ組み込みの多態的ディスパッチを使用することで、ディスパッチコードをたくさん書く必要がないことです。

また、マルチメソッドは、一方のクラスセットを他方と強く結びつける必要がないため、クラス同士の緊密な結合から解放されます。ドラムとスティックの例では、ドラムクラスの実装がさまざまなスティックのクラスについて知っている必要はなく、スティックのクラスがさまざまなドラムのクラスについて知っている必要もありません。マルチメソッドは、クラス自身の協力なしに、独立したクラス同士を接続して共同の振る舞いを記述します。

** 続きは次回で…

基本的な部分、そして少しその先までのジェネリック関数、すなわちCommon Lispのオブジェクトシステムの動詞について説明しました。次の章では、自分自身のクラスを定義する方法をお見せします。
