* オブジェクト再指向：ジェネリック関数
Lispの発明はオブジェクト指向プログラミングの台頭よりも数十年早かったため、新しいLisper（Lispユーザー）はCommon Lispが非常にオブジェクト指向的な言語であることに驚くことがあります。Common Lispの直近の前身は、オブジェクト指向が新しくエキサイティングなアイデアであった時代に開発され、特にSmalltalkに見られるようなオブジェクト指向のアイデアをLispに取り込むためのさまざまな試みが行われました。Common Lispの標準化の一環として、これらの試みのいくつかが「Common Lisp Object System（CLOS）」という名の下に統合されました。ANSI標準はCLOSを言語に組み込み、CLOSを独立したものとして話すことはもはや意味を成しません。

CLOSがCommon Lispに提供した機能は、避けられないものから、Lispの「言語を構築するためのツール」という哲学の一風変わった表現まで幅広くあります。これらの機能すべてを完全にカバーすることはこの本の範囲を超えますが、この章と次の章で、基本的な機能を説明し、Common Lispのオブジェクトに対するアプローチの概要をお伝えします。

まず、Common Lispのオブジェクトシステムは、他の多くの言語と比較して、オブジェクト指向の原則をかなり異なる形で具現化していることを留意してください。オブジェクト指向の基本的なアイデアを深く理解しているなら、Common Lispがそのアイデアを特に強力で一般的な方法で表現していることを評価できるでしょう。しかし、もしオブジェクト指向に関して特定の言語にしか経験がない場合は、Common Lispのアプローチがやや異質に感じるかもしれません。その場合、一つの言語だけがオブジェクト指向をサポートする方法だと決めつけないようにしましょう。オブジェクト指向プログラミングの経験がほとんどない場合でも、ここでの説明を理解するのに問題はないはずです。他の言語との比較に惑わされないようにすると良いでしょう。

** ジェネリック関数とクラス
オブジェクト指向の基本的なアイデアは、プログラムを整理する強力な方法として、データ型を定義し、そのデータ型に操作を関連付けるというものです。特に、操作を呼び出したときに、その操作が適用されるオブジェクトの型によって正確な動作が決まるようにしたいのです。オブジェクト指向に関する入門書でよく使われる古典的な例として、さまざまな幾何学的図形を表すオブジェクトに対して適用できる操作「draw」があります。円や三角形、四角形を描画するための異なる実装を提供でき、drawの呼び出しは、その操作が適用されるオブジェクトの型に応じて実際に円、三角形、または四角形を描画することになります。drawの異なる実装は別々に定義され、他のdrawの実装や呼び出し側のコードを変更することなく、新しい図形を描画するためのバージョンを追加できます。このオブジェクト指向の特徴は、ギリシャ語で「多くの形」を意味する「ポリモーフィズム（多相性）」と呼ばれます。これは、1つの概念的な操作（例えばオブジェクトの描画）が、さまざまな具体的な形を取ることができるからです。

Common Lispは、今日のほとんどのオブジェクト指向言語と同様に、クラスベースです。すべてのオブジェクトは特定のクラスのインスタンスです。オブジェクトのクラスはその表現を決定します。NUMBERやSTRINGといった組み込みクラスは、不透明な表現を持ち、それらの型を操作するための標準関数を介してのみアクセス可能です。ユーザー定義クラスのインスタンスは、次章で説明するように、スロットと呼ばれる名前付きの部分から構成されます。

クラスは階層的に配置されており、すべてのオブジェクトに対する分類法を形成しています。クラスは他のクラスのサブクラスとして定義され、そのクラスのスーパークラスと呼ばれます。クラスはその定義の一部をスーパークラスから継承し、クラスのインスタンスはスーパークラスのインスタンスとしても扱われます。Common Lispでは、クラスの階層は単一のルート、すなわちクラスTに集約され、Tはすべての他のクラスの直接または間接的なスーパークラスです。したがって、Common LispのすべてのデータはTのインスタンスです。また、Common Lispは多重継承をサポートしており、1つのクラスが複数の直接のスーパークラスを持つことができます。

Lisp以外では、ほとんどすべてのオブジェクト指向言語が、Simulaによって確立された基本パターンに従い、クラスに関連付けられたメソッドやメンバ関数を使用しています。これらの言語では、特定のオブジェクトに対してメソッドが呼び出され、そのオブジェクトのクラスが実行されるコードを決定します。このメソッド呼び出しのモデルはSmalltalkの用語に従い、「メッセージパッシング」と呼ばれます。概念的には、メッセージパッシングシステムにおけるメソッド呼び出しは、実行するメソッドの名前と引数を含むメッセージを、そのメソッドが呼び出されるオブジェクトに送信することから始まります。オブジェクトは、そのクラスを使用してメッセージ内の名前に関連付けられたメソッドを検索し、それを実行します。各クラスは、特定の名前に対して独自のメソッドを持つことができるため、同じメッセージを異なるオブジェクトに送信すると、異なるメソッドが呼び出される可能性があります。

初期のLispオブジェクトシステムも似たような動作をしており、特定のオブジェクトにメッセージを送信するためにSENDという特別な関数を提供していました。しかし、この方法は完全には満足できるものではありませんでした。メソッド呼び出しが通常の関数呼び出しと異なるものになってしまったからです。構文的には、メソッド呼び出しは次のように記述されます。

#+begin_src lisp
  (send object 'foo)  
#+end_src

これに対して通常の関数呼び出しは次のようになります。

#+begin_src lisp
  (foo object)
#+end_src

さらに重要なのは、メソッドが関数ではなかったため、高階関数（例えばMAPCAR）の引数として渡すことができなかった点です。リストのすべての要素に対してMAPCARを使用してメソッドを呼び出したい場合、次のように書かなければなりませんでした。

#+begin_src lisp
  (mapcar #'(lambda (object) (send object 'foo)) objects)
#+end_src

これに対して、通常の関数呼び出しであれば次のように書けるはずです。

#+begin_src lisp
  (mapcar #'foo objects)
#+end_src

最終的に、Lispオブジェクトシステムを開発していた人々は、メソッドと関数を統合し、ジェネリック関数と呼ばれる新しい種類の関数を作り出しました。これにより、上記の問題が解決されただけでなく、メッセージパッシングのオブジェクトシステムでは意味をなさない多くの機能をオブジェクトシステムに導入することができました。

ジェネリック関数はCommon Lispのオブジェクトシステムの中心であり、この章の残りで取り扱うテーマです。クラスについても少し触れざるを得ませんが、ここではジェネリック関数の定義と使用に焦点を当てます。次章では、自分自身のクラスを定義する方法を紹介します。

** ジェネリック関数とメソッド
ジェネリック関数は抽象的な操作を定義し、その名前とパラメータリストを指定しますが、実装は提供しません。例えば、画面にさまざまな形を描画するために使うジェネリック関数 `draw` を次のように定義することができます。

#+begin_src lisp
  (defgeneric draw (shape)
    (:documentation "Draw the given shape on the screen."))
#+end_src

ここでは `DEFGENERIC` の構文について次のセクションで説明しますが、今のところこの定義には実際のコードが含まれていないことに注目してください。

ジェネリック関数は理論的にはどんなオブジェクトも引数として受け入れられるため、「ジェネリック」と呼ばれています。しかし、それ自体では何も実行できません。ジェネリック関数だけを定義しても、どんな引数で呼び出してもエラーが発生します。ジェネリック関数の実際の実装は、メソッドによって提供されます。各メソッドは特定のクラスの引数に対してジェネリック関数の実装を提供します。ジェネリック関数ベースのシステムとメッセージパッシングシステムの最大の違いは、メソッドがクラスに属さず、ジェネリック関数に属していることです。ジェネリック関数が呼び出された際、どのメソッドを実行するかを決定するのはジェネリック関数の役割です。

メソッドは、ジェネリック関数で定義された必須パラメータを「特化」することで、対応できる引数の種類を示します。例えば、ジェネリック関数 `draw` では、`shape` パラメータをクラス `circle` のインスタンスに特化したメソッドや、クラス `triangle` のインスタンスに特化したメソッドを定義できます。それらのメソッドは次のようになります（描画の実装コードは省略します）。

#+begin_src lisp
  (defmethod draw ((shape circle))
    ...)

  (defmethod draw ((shape triangle))
    ...)
#+end_src

ジェネリック関数が呼び出されると、渡された実際の引数を各メソッドの特化と比較し、適用可能なメソッドを見つけ出します。たとえば、`draw` を呼び出して `circle` のインスタンスを渡すと、`shape` をクラス `circle` に特化したメソッドが適用されます。同様に、`triangle` を渡すと `triangle` に特化したメソッドが適用されます。単純なケースでは1つのメソッドだけが適用可能で、そのメソッドが呼び出しを処理します。しかし、複雑なケースでは複数のメソッドが適用される場合があり、それらは「メソッドの組み合わせ」セクションで説明するように、1つの有効なメソッドとして結合されて呼び出しを処理します。

パラメータを特化する方法は2つあります。通常は、引数が特定のクラスのインスタンスでなければならないことを指定します。クラスのインスタンスは、そのクラスのスーパークラスのインスタンスとしても扱われるため、特定のクラスに特化したパラメータを持つメソッドは、対応する引数がそのクラスやそのサブクラスの直接のインスタンスである場合に適用可能となります。もう一つの特化方法は、特定のオブジェクトに適用されるメソッドを指定する「EQL特化子」と呼ばれるものです。

ジェネリック関数が単一のパラメータに特化したメソッドしか持たず、すべての特化子がクラス特化子である場合、ジェネリック関数の呼び出しの結果は、メッセージパッシングシステムでメソッドを呼び出す結果と非常に似ています。つまり、操作の名前とそれが呼び出されるオブジェクトのクラスの組み合わせが、実行されるメソッドを決定します。

しかし、ルックアップの順序を逆にすることで、メッセージパッシングシステムにはない可能性が開かれます。ジェネリック関数は、複数のパラメータに特化したメソッドをサポートし、複数の継承をより管理しやすくするためのフレームワークを提供し、メソッドがどのように効果的なメソッドに結合されるかを制御するための宣言的な構造を使用できるようにします。これにより、多くの一般的な使用パターンが、煩雑なコードなしにサポートされます。

次に、このジェネリック関数とメソッドを定義するために使用される2つのマクロ `DEFGENERIC` と `DEFMETHOD` の基本について説明します。

** DEFGENERIC

