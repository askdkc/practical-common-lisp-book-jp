* 1. 導入：なぜLispか？

もし、プログラミングにおいて最大の喜びが、コードによって意図を単純かつ明確に表現しながら多くのことを成し遂げることだと感じるなら、Common Lispでのプログラミングは、コンピュータでできる最も楽しい体験になるでしょう。Lispを使えば、ほとんどの他の言語よりも、より多くのことを、より速く達成することができるはずです。

これは大胆な主張です。これを正当化できるでしょうか？この章の数ページでは難しいかもしれません—いくつかのLispを学び、自分で確かめてください。そのためにこの本の残りが存在します。今は、いくつかの逸話的な証拠として、私自身のLispへの道のりをお話しします。そして次のセクションでは、Common Lispを学ぶことで得られるリターンについて説明します。

私は、おそらく非常に少ない「第二世代のLispハッカー」の一人です。私の父は、物理学の博士論文のデータ収集に使った機械のために、アセンブリ言語でオペレーティングシステムを書いたことで、コンピュータの世界に足を踏み入れました。さまざまな物理学の研究所でコンピュータシステムを運用した後、1980年代には物理学を完全に離れ、大手製薬会社に勤めるようになりました。その会社では、化学工場の生産プロセスをモデル化するソフトウェアを開発するプロジェクトが進行中でした—もしこの容器のサイズを増やしたら、年間生産量にどう影響するのか？元のチームはFORTRANでプログラムを書いていましたが、予算の半分とほとんどの時間を使い切りながらも、結果は何も出せていませんでした。1980年代であり、人工知能（AI）ブームの真っ只中であったため、Lispが注目されていました。父は当時、Lisper（Lisp使い）ではありませんでしたが、Carnegie Mellon University（CMU）を訪れ、後にCommon Lispとなるものに取り組んでいた人々に会い、このプロジェクトにLispが適しているかどうかを相談しました。

CMUの人々は自分たちが取り組んでいたデモを父に見せました。彼は説得され、彼のボスたちに、失敗しかけたプロジェクトをLispで再スタートさせる許可を得るよう説得しました。1年後、彼のチームは、元の予算の残りだけで、元のチームが諦めていた機能を含む動作するアプリケーションを提供しました。父は、この成功をLispの選択にあると考えています。

もちろん、これは単なる逸話にすぎませんし、父が成功の理由について誤解しているかもしれません。また、Lispが当時の他の言語と比較して優れていたかもしれませんが、現代では多くの新しい言語が登場し、多くがLispの機能を取り入れています。それでも、私は本当に、Lispが今日でも、1980年代の父にとって提供したような利点を提供できると言っているのでしょうか？続きをお読みください。

父の最善の努力にもかかわらず、私は高校時代にLispを学びませんでした。大学ではあまりプログラミングに関わらなかったものの、インターネットに惹かれて再びコンピュータの世界に戻りました。最初はPerlで仕事をし、「Mother Jones」誌のウェブサイトのためにオンラインディスカッションフォーラムを構築し、その後「Organic Online」というウェブショップで、1996年のオリンピック期間中にNikeが立ち上げたような大規模なウェブサイトに取り組みました。その後、WebLogicという会社の初期開発者としてJavaに移行しました。WebLogicの後、別のスタートアップに参加し、Javaでトランザクションメッセージングシステムを開発するチームのリードプログラマーとして働きました。

** Lispの始まり

Common Lispは、1956年にJohn McCarthyによって最初に構想されたLisp言語の現代的な子孫です。1956年当時のLispは「記号データ処理」7のために設計され、その得意分野の1つにちなんで名付けられました：LISt Processing（リスト処理）。それ以来、私たちは大きな進化を遂げました。Common Lispは、現代のデータ型を豊富に備えています。たとえば、第19章で紹介する条件システムは、Java、Python、C++の例外システムには欠けている柔軟性を提供します。オブジェクト指向プログラミングを行うための強力な機能もあり、他のプログラミング言語には存在しないさまざまな言語機能を備えています。これがどのように可能になったのでしょうか？なぜこんなに優れた機能を持つ言語に進化したのでしょうか？

それは、McCarthyが人工知能（AI）研究者であり、彼が初期のLispバージョンに組み込んだ多くの機能が、AIプログラミングに適していたためです。1980年代のAIブームの間、Lispは、自動定理証明、計画とスケジューリング、コンピュータビジョンなどの難解な問題を解決するためのソフトウェアを書くプログラマーにとって、お気に入りのツールでした。これらの問題は、多くの書きにくいソフトウェアを必要としました。AIプログラマーは、強力な言語が必要だったため、Lispを自分たちが必要とする言語に育てました。そして冷戦が助けました。ペンタゴンが国防高等研究計画局（DARPA）に資金を投入すると、その多くは、戦場シミュレーション、計画の自動化、自然言語インターフェースなどの問題に取り組む人々に流れました。これらの人々もLispを使用し、必要なことを実行できるようLispを発展させ続けました。

Lispの機能進化を駆動した同じ力が、他の側面にも影響を与えました。大規模なAI問題は、どのようにコード化しても多くのコンピュータ資源を消費します。1980年代のハードウェア上で、どれだけコンピュータ資源が乏しかったかを想像するには、ムーアの法則を20年逆転させると良いでしょう。Lisp開発者は、実装から性能を引き出すために、さまざまな工夫をする必要がありました。現代のCommon Lisp実装は、これらの初期の努力を継承し、多くの場合、非常に高度なネイティブ機械語を生成するコンパイラを含んでいます。ムーアの法則のおかげで、今日では純粋にインタープリタ言語からでも使える性能を得ることが可能ですが、Common Lispにとってそれはもはや問題ではありません。第32章で説明するように、適切な（オプションの）宣言を使用すれば、優れたLispコンパイラは、Cコンパイラが生成する機械語とほぼ同等のものを生成することができます。

1980年代はまた、Lispマシンの時代でもあり、特に有名なのはSymbolicsなど、いくつかの企業がLispをネイティブに動作させるコンピュータをチップから作っていました。このようにして、Lispはシステムプログラミング言語にもなり、オペレーティングシステム、エディタ、コンパイラ、その他Lispマシン上で動作するほとんどすべてのものを書くために使用されました。

実際、1980年代初頭までには、さまざまなAIラボやLispマシンベンダーがそれぞれ独自のLisp実装を提供していたため、Lispシステムや方言が非常に多様化し、DARPAの関係者はLispコミュニティが分裂していることを懸念するようになりました。この懸念に対処するため、1981年にLispハッカーの草の根グループが集まり、既存のLisp方言のベストな機能を組み合わせた新しい言語「Common Lisp」の標準化プロセスが始まりました。彼らの作業は、Guy Steele著の「Common Lisp the Language」（Digital Press、1984年）という本に記録されました—Lispの通には「CLtL」として知られています。

1986年には最初のCommon Lisp実装が登場し、それが置き換えようとしていた方言には終焉の兆しが見え始めました。1996年には、米国規格協会（ANSI）がCLtLで定義された言語を基に、CLOSや条件システムなどの主要な新機能を追加したCommon Lispの標準を発表しました。そして、それが最後の言葉ではありませんでした。CLtLの前例に倣って、ANSI標準も実装者が最適な方法を模索できるように意図的に余地を残しています。完全なLisp実装は、GUIウィジェット、複数の制御スレッド、TCP/IPソケットなどへのアクセスを提供する豊富なランタイム環境を提供します。今日では、Common Lispは他のオープンソース言語と同様に進化しており、使用者が必要なライブラリを作成し、それを他の人々にも提供することが一般的になっています。特にここ数年では、オープンソースのLispライブラリが急速に増えています。

したがって、ある意味では、Lispはコンピュータサイエンスの「古典的」言語の1つであり、時の試練に耐えたアイデアに基づいています8。他方では、現代的な汎用言語でもあり、現実の問題をできるだけ効率的かつ堅牢に解決するための実際的なアプローチを反映した設計を持っています。Lispの「古典的」遺産の唯一の欠点は、McCarthyがLispを発明して以来のほぼ半世紀にわたるさまざまなLisp方言に触れた特定の時期の知識に基づいて、Lispについての誤解を持ち続けている人々が多いことです。誰かがLispはインタープリタ専用であるとか、遅いとか、すべてのことに再帰を使わなければならないと言ってきたら、彼らがどのLisp方言を指しているのか、そして彼らがそれを学んだ時代にはベルボトムズが流行していたのかを聞いてみてください。

 #+BEGIN_QUOTE
** かつてLispを学んだことがあるけど、ここの説明とは違う？
もし過去にLispを使ったことがあるなら、「Lisp」とはこういうものだという考えを持っているかもしれませんが、それはCommon Lispとはあまり関係がないかもしれません。Common Lispは、それが派生したほとんどの方言を置き換えましたが、残っているLisp方言の1つでしかなく、どこで、いつLispに触れたかによっては、他の方言の1つを学んだ可能性も十分にあります。

Common Lisp以外で、今も活発なユーザーコミュニティを持つ汎用Lisp方言としては、Schemeが挙げられます。Common Lispはいくつかの重要な機能をSchemeから取り入れましたが、Schemeを置き換えることは意図していませんでした。

元々M.I.T.で設計され、すぐに学部のコンピュータサイエンスコースの教育言語として使用されるようになったSchemeは、Common Lispとは異なる言語のニッチを目指していました。特に、Schemeの設計者はコア言語をできるだけ小さくシンプルに保つことに焦点を当ててきました。これは教育用言語としての明確な利点があり、また、言語について正式に証明することを好むプログラミング言語研究者にも適しています。

また、標準に指定された全言語を比較的簡単に理解できるという利点もあります。しかし、その代償として、Common Lispに標準化されている多くの便利な機能が省略されているのです。個々のScheme実装はこれらの機能を実装固有の方法で提供することがありますが、標準からそれらが省略されているため、ポータブルなSchemeコードを書くのがCommon Lispコードを書くよりも難しくなります。

さらに、SchemeはCommon Lispよりも、関数型プログラミングスタイルや再帰の使用を強調しています。大学でLispを学び、Lispは学術的な言語で、現実の世界では使い道がないという印象を持っていたなら、おそらくSchemeを学んだのでしょう。これはSchemeに対して特に公平な評価とは言えませんが、Common Lispにはさらに当てはまりません。Common Lispは理論的に「純粋」な言語ではなく、実際のエンジニアリング言語として設計されたのです。

Schemeを学んだ経験があるなら、SchemeとCommon Lispの間に存在するいくつかの微妙な違いに注意する必要があります。これらの違いは、Common LispコミュニティとSchemeコミュニティの間で長年続いている宗教的論争の元でもあります。進行中に重要な違いについて指摘することにします。

まだ広く使われている他のLisp方言には、Emacsエディタの拡張言語であるElispと、AutodeskのAutoCADコンピュータ支援設計ツールの拡張言語であるAutolispがあります。ElispとAutolispで書かれたコード行数は他のLisp方言よりも多いかもしれませんが、これらはホストアプリケーションの外で使うことはできませんし、SchemeやCommon Lispに比べてどちらも非常に時代遅れのLispです。これらの方言のどれかを使用していた場合は、Lispのタイムマシンに乗り込み、数十年先にジャンプする準備をしてください。
 #+END_QUOTE

** この本は誰向けのものか

この本は、Common Lispに興味がある人のためのものです。すでにCommon Lispを使いたいと確信している人でも、なぜそんなに話題になっているのか知りたいだけの人でも、この本は役立つでしょう。

すでにLispを少し学んでいても、学問的な演習から実際のプログラムに飛躍するのに苦労しているなら、この本が助けになるはずです。逆に、Lispを使うと確信していないとしても、この本から何かを得ることができるでしょう。

もし、Perl、Python、Java、C、またはC#のような言語に対して、Common Lispがどのような利点を持っているのかを知りたい現実的なプログラマーであれば、この本はあなたにいくつかのヒントを提供するはずです。あるいは、Lispを使うこと自体には興味がなく、Lisper（Lispを愛用する人）が「君が理解していないだけだ」と言ってくることにイライラしているなら、この本はCommon Lispへの率直な入門書となるでしょう。この本を読んだ後でも、Common Lispがあなたの現在のお気に入りの言語よりも優れていないと考えるなら、なぜそう思うのか正確に説明できるようになるでしょう。

この本では、言語の文法や意味論だけでなく、実際に役立つソフトウェアを書く方法についても説明します。本の前半では、いくつかの「実践的な」章を織り交ぜながら言語そのものを取り上げ、実際のコードの書き方を紹介します。そして、言語のほとんど、他の本があなた自身で学ぶようにしているいくつかの部分を含めて説明した後、本の残りの部分では、役に立つかもしれない中規模のプログラムをいくつか書くための9つの実践的な章が続きます：スパムをフィルタリングする、バイナリファイルを解析する、MP3をカタログ化する、ネットワーク上でMP3をストリーミングする、そしてそのMP3カタログとサーバーのためにウェブインターフェースを提供する、といったものです。

この本を読み終わる頃には、言語の最も重要な機能のすべてに精通し、それらがどのように組み合わさっているのか理解し、Common Lispを使っていくつかの実用的なプログラムを書き、さらに自分で言語を探求していく準備が整っているでしょう。誰もがLispに至る道は異なりますが、この本がその道を少しでも平坦にする助けになれば幸いです。では、始めましょう。
