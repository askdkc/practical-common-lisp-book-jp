* 2. 洗う、濯ぐ、繰り返す：REPLのツアー

この章では、プログラミング環境をセットアップし、最初のCommon Lispプログラムを書きます。私たちは、Matthew DanishとMikel Evinsによって開発された「Lisp in a Box」を使用します。これは、Common Lisp実装とEmacsという強力なLisp対応のテキストエディタ、およびEmacsの上に構築されたCommon Lisp開発環境であるSLIMEをパッケージ化したものです。

この組み合わせは、Lispプログラミングを特徴づけるインクリメンタルでインタラクティブな開発スタイルをサポートする、最先端のCommon Lisp開発環境を提供します。さらに、SLIME環境は、使用するオペレーティングシステムやCommon Lispの実装に関係なく、比較的統一されたユーザーインターフェースを提供するという利点もあります。ここでは、特定の開発環境について説明するために「Lisp in a Box」を使用しますが、グラフィカルな統合開発環境（IDEs）を提供する商用Lispベンダーや他のエディタに基づいた環境を探求したい方でも、基本を変換するのにそれほど苦労しないはずです。

** Lisp実装の選択

最初に行うべきことは、Lispの実装を選ぶことです。Perl、Python、Visual Basic (VB)、C#、Javaのような言語に慣れている人にとって、Lispの実装を選ぶのは奇妙に思えるかもしれません。Common Lispとこれらの言語の違いは、Common Lispがその標準によって定義されている点です。PerlやPythonのように「慈悲深い独裁者」がコントロールする単一の実装が存在するわけでもなく、VB、C#、Javaのように単一の会社が管理する正典的な実装が存在するわけでもありません。Common Lispの標準を読んで言語を実装したいと思う人なら誰でも、それを自由に行うことができます。さらに、標準への変更は、アメリカ国立規格協会（ANSI）によって管理されるプロセスに従って行う必要があります。このプロセスは、単一のベンダーのような一つの団体が標準を独断で変更できないようにするためのものです。したがって、Common Lispの標準は、どのCommon Lispベンダーとプログラマーとの間でも契約として機能します。その契約は、標準で記述されている言語の機能を使用してプログラムを書くと、そのプログラムがどの準拠した実装でも同じように動作することを保証するものです。

一方で、標準がカバーしていない機能もあり、プログラムでやりたいことが全て含まれているわけではありません。ある機能を言語にどうサポートするのが最善かについてコンセンサスが得られなかった分野では、実装者が継続的に実験できるように、いくつかの事項は意図的に指定されていません。そのため、各実装は、標準で規定されているものを超えるいくつかの機能を提供しています。どのようなプログラミングをするかによって、必要な追加機能を持つ一つの実装を選び、それを使うのが理にかなっているかもしれません。一方、他の人が使用するためにLispソースを提供する場合、たとえばライブラリのようなものを提供する場合は、できるだけポータブルなCommon Lispを書くことを目指すべきです。標準で定義されていない機能を必要とするが、主にポータブルなコードを書く場合には、Common Lispは特定の実装で利用可能な機能に応じた「条件付き」コードを書くための柔軟な方法を提供します。第15章で、異なるLisp実装がファイル名をどのように扱うかの違いを平滑化する単純なライブラリを開発する際に、この種のコードの例を見ていきます。

今のところ、最も重要な実装の特徴は、お気に入りのオペレーティングシステム上で動作するかどうかです。Allegro Common Lispを製造しているFranz社は、この本で使用するためにLinux、Windows、OS X上で動作する製品の試用版を提供しています。オープンソースの実装を探している方には、いくつかのオプションがあります。SBCL4は、高品質なオープンソースの実装で、ネイティブコードにコンパイルし、LinuxやOS Xを含む多くのUnix系システムで動作します。SBCLはCMUCL5から派生したもので、Carnegie Mellon大学で開発されたCommon Lispであり、ほとんどがパブリックドメインに属していますが、一部はBerkeley Software Distribution（BSD）スタイルのライセンスの下で提供されています。CMUCL自体も素晴らしい選択ですが、SBCLはインストールが容易で、21ビットのUnicodeをサポートしています。OS Xユーザーには、OpenMCLが優れた選択肢であり、マシンコードにコンパイルし、スレッドをサポートし、OS XのCarbonやCocoaツールキットとの統合が非常に良好です。他にもオープンソースおよび商用の実装が利用可能です。第32章では、これらの実装に関する詳細なリソースを紹介します。

この本に掲載されているLispコードは、特に記載がない限り、すべての準拠したCommon Lisp実装で動作するはずです。また、SLIMEは、Lispと対話するための共通インターフェースを提供することで、実装間の違いをある程度解消します。この本で示されている出力は、GNU/Linux上で動作するAllegroのものです。他のLispでは、場合によっては多少異なるエラーメッセージやデバッガの出力が生成されることがあります。

** Lisp開発キットのセットアップ

Lisp開発キットのパッケージは、新しいLisperが最先端のLisp開発環境を最小限の手間で立ち上げるために設計されています。そのため、Lisp開発キットを動作させるには、32章に記載されているWebサイトから、お使いのオペレーティングシステムに適したパッケージと、希望するLispを取得し、インストール手順に従うだけです。

Lisp開発キットはエディタとしてEmacsを使用しているため、少なくともEmacsの使い方について多少の知識が必要です。Emacsを始める最良の方法は、組み込みのチュートリアルを進めることです。チュートリアルを始めるには、ヘルプメニューの最初の項目「Emacs tutorial」を選択します。または、Ctrlキーを押しながらhをタイプし、Ctrlキーを離してからtを押します。Emacsのコマンドの多くは、このようなキーの組み合わせでアクセスできます。キーの組み合わせが非常に一般的であるため、Emacsユーザーはキーの組み合わせを説明するための表記法を持っています。たとえば、先ほど説明したチュートリアルを始めるためのキーの組み合わせは、次のように表記できます：C-h t。

チュートリアルでは、他の便利なコマンドや、それらを呼び出すためのキーの組み合わせについても説明しています。Emacsには、Infoという組み込みのハイパーテキストドキュメントブラウザを使って、広範なオンラインドキュメントも付属しています。マニュアルを読むには、C-h iをタイプします。Infoシステムには、hを押すことでアクセスできるチュートリアルも含まれています。最後に、EmacsはC-hから始まるキーコンボに結びつけられた多くのヘルプ機能を提供しています。C-h ?を入力すると、完全なリストが表示されます。特に便利なものとしては、チュートリアルの他に、C-h kというキーコンボがあり、任意のキーコンボを入力すると、そのコンボが呼び出すコマンドが表示されます。また、C-h wでは、コマンドの名前を入力すると、それに対応するキーコンボが表示されます。

チュートリアルを実行しない人のために、もう一つ覚えておくべきEmacsの重要な用語は「バッファ」の概念です。Emacsで作業していると、編集している各ファイルは異なるバッファによって表されますが、任意の時点で「カレント」としてアクティブなのは一つのバッファだけです。カレントバッファは、あなたがタイプしたすべての入力や、呼び出したコマンドを受け取ります。バッファは、Common Lispのようなプログラムとの対話を表すためにも使用されます。そのため、一般的な操作の一つとして「バッファの切り替え」があり、これにより、異なるバッファをカレントバッファにして特定のファイルを編集したり、特定のプログラムと対話したりします。switch-to-bufferというコマンドは、C-x bというキーコンボに結びつけられており、Emacsフレームの下部に表示されるエリアでバッファ名を入力するよう促されます。バッファ名を入力するとき、Tabを押すと、これまでに入力された文字に基づいて名前が補完されるか、または可能な補完のリストが表示されます。プロンプトはデフォルトのバッファも提案しますが、それを受け入れるにはReturnキーを押すだけです。また、バッファメニューからバッファを選択してバッファを切り替えることもできます。

特定の状況では、特定のバッファに切り替えるための別のキーコンボが利用可能になる場合もあります。たとえば、Lispのソースファイルを編集しているとき、キーコンボC-c C-zは、Lispと対話するバッファに切り替えます。

** 心を解き放つ：インタラクティブなプログラミング

Lisp開発キットを起動すると、次のようなプロンプトが表示されたバッファが見えるはずです：

#+begin_src lisp
CL-USER>
#+end_src

これはLispのプロンプトです。UnixやDOSのシェルプロンプトのように、Lispプロンプトは何かを起こすために式を入力する場所です。しかし、シェルコマンドを読み取り解釈する代わりに、LispはLisp式を読み取り、それをLispのルールに従って評価し、結果を出力します。そして、次に入力された式で同じことを繰り返します。この「読み取り・評価・出力」の無限ループが、REPL（Read-Eval-Print Loop）と呼ばれる所以です。これをトップレベル、トップレベルリスナー、またはLispリスナーと呼ぶこともあります。

REPLが提供する環境内で、変数、関数、クラス、メソッドなどのプログラム要素を定義および再定義することができます。また、任意のLisp式を評価したり、Lispソースコードやコンパイル済みコードを含むファイルを読み込んだり、ファイル全体や個々の関数をコンパイルしたり、デバッガに入ったり、コードをステップ実行したり、個々のLispオブジェクトの状態を調査することができます。

これらすべての機能は言語に組み込まれており、言語標準で定義された関数を通じてアクセス可能です。必要があれば、REPLとLispコードを適切にインデントするテキストエディタだけでも、十分に使えるプログラミング環境を構築することができます。しかし、本当のLispプログラミング体験をするには、SLIMEのような環境が必要です。SLIMEは、REPLを介してLispと対話しながら、ソースファイルを編集することも可能にします。たとえば、関数定義をソースファイルからREPLにコピペしたり、関数を1つ変更しただけでファイル全体を読み込む必要がないようにするには、Lisp環境がエディタから直接個々の式やファイル全体を評価・コンパイルできる必要があります。

** REPLでの実験

REPLを試すには、Lispが読み取り、評価し、出力できるLisp式が必要です。最も簡単なLisp式の一つは数字です。Lispプロンプトで「10」と入力し、Returnキーを押すと、次のような出力が表示されるはずです：

#+begin_src lisp
CL-USER> 10
10
#+end_src

最初の「10」はあなたが入力したものです。Lispリーダー（REPLのR）が「10」というテキストを読み取り、数値10を表すLispオブジェクトを作成します。このオブジェクトは自己評価オブジェクトと呼ばれ、評価器（REPLのE）に与えられるとそれ自身を評価します。この値はプリンターに渡され、「10」として表示されます。単純に元に戻っただけのように見えるかもしれませんが、もっと複雑な式を与えると、Lispの力が発揮されます。たとえば、Lispプロンプトで「(+ 2 3)」と入力します。
#+begin_src lisp
CL-USER> (+ 2 3)
5
#+end_src

括弧内のすべてはリストです。この場合、3つの要素（記号「+」と数字「2」と「3」）からなるリストです。Lispは通常、リストを評価するとき、最初の要素を関数の名前とみなし、残りの要素を評価して関数の引数として使用します。この場合、記号「+」は加算を行う関数の名前です。「2」と「3」はそれぞれ自己評価オブジェクトとして評価され、加算関数に渡されます。そして、関数が「5」を返します。この「5」はプリンターに渡され、出力されます。Lispがリスト式を評価する他の方法もありますが、それについては後ほど学びます。

** Lispスタイルの「Hello, World」

どのプログラミング書にも欠かせない「Hello, World」プログラムですが、REPLで「hello, world」を表示するのは非常に簡単です。

#+begin_src lisp
CL-USER> "hello, world"
"hello, world"
#+end_src

これは、文字列が数字と同様にリテラル構文を持ち、自己評価オブジェクトだからです。Lispリーダーがダブルクォーテーション付きの文字列を読み取り、メモリに文字列オブジェクトを作成します。このオブジェクトは評価されると自己を評価し、同じリテラル構文で出力されます。引用符はメモリ内の文字列オブジェクトの一部ではなく、リーダーが文字列を読み取るための構文です。プリンターは、リーダーが理解できる構文でオブジェクトを出力するため、引用符を付けて表示します。

ただし、これは「Hello, World」プログラムとは言いにくく、むしろ「Hello, World」値に近いです。

次のステップとして、標準出力に「hello, world」を表示するコードを書いて、実際にプログラムの一部として動作させることができます。Common Lispには出力を行ういくつかの方法がありますが、最も柔軟なのはFORMAT関数です。FORMATは可変引数を取りますが、必要なのは出力先と文字列の2つの引数です。次の章で、文字列に組み込みのディレクティブを使って引数を埋め込む方法を学びますが、ここでは、文字列が~を含まない限り、そのまま出力されることを覚えておけば十分です。最初の引数にtを渡すと、標準出力に結果が送られます。次のようにFORMAT式を使って「hello, world」を表示できます：

#+begin_src lisp
CL-USER> (format t "hello, world")
hello, world
NIL
#+end_src

FORMAT式の結果として「hello, world」の出力後に表示される「NIL」に注目してください。これはREPLがFORMAT式を評価した結果です。（NILはLispにおける偽値またはnullを表します。詳細は第4章で説明します。）FORMAT式は、標準出力に文字列を表示するという副作用があり、それが主な目的であるため、返される値はそれほど重要ではありません。しかし、Lispではすべての式が何らかの結果を評価します。

これで、ほぼ「プログラム」と呼べるものを書いたと言えます。今度は、このコードを関数にまとめましょう。関数はLispの基本的なプログラム構築ブロックの1つであり、DEFUN式を使って定義できます。次のように記述します：

#+begin_src lisp
CL-USER> (defun hello-world () (format t "hello, world"))
HELLO-WORLD
#+end_src

DEFUNの後の「hello-world」は関数の名前です。第4章で名前に使用できる文字について詳しく説明しますが、今は他の言語では使用できない文字（例：-）もCommon Lispでは合法であることを覚えておけば十分です。Lispの標準的なスタイルでは、複合名をハイフンで区切るのが一般的です。hello_worldやhelloWorldといった名前付けよりも、hello-worldのほうが自然な英語のタイポグラフィに沿っています。名前の後ろの()はパラメータリストを区切っており、今回は関数が引数を取らないため空です。残りは関数の本体です。

一つ段階では、この式も他のものと同様、REPLによって読み取られ、評価され、印刷される単なる式に過ぎません。この場合、戻り値は定義した関数の名前です。しかし、FORMAT式と同様、この式は副作用が主な関心事であり、戻り値自体はあまり重要ではありません。FORMAT式とは異なり、この副作用は目に見えません。この式が評価されると、引数を取らず、本文が「(format t "hello, world")」の新しい関数が作成され、その名前がHELLO-WORLDに割り当てられます。

関数を定義した後、それを次のように呼び出すことができます：

#+begin_src lisp
CL-USER> (hello-world)
hello, world
NIL
#+end_src

FORMAT式を直接評価したときと同様の出力が表示され、NIL値もREPLによって表示されます。Common Lispの関数は、最後に評価された式の値を自動的に返します。

** 作業を保存する

これはある意味「hello, world」プログラムとして完結していると言えます。しかし、まだ問題があります。Lispを終了して再起動すると、関数定義が消えてしまいます。せっかく書いた素晴らしい関数なので、作業を保存したくなるでしょう。

簡単な方法です。定義を保存するためのファイルを作成するだけです。Emacsでは、C-x C-fと入力してファイルを作成できます。Emacsはプロンプトを表示するので、作成したいファイルの名前を入力します。ファイルの保存場所は特に問題ありませんが、Common Lispのソースファイルは慣例として.lisp拡張子を持つように名付けるのが一般的です（ただし、一部の人は.clを使うこともあります）。

ファイルを作成したら、以前REPLで入力した定義を入力できます。注目すべき点として、開き括弧とDEFUNの単語を入力すると、Emacsのウィンドウの下部にSLIMEが期待する引数が表示されます。具体的な形式は使用しているCommon Lispの実装に依存しますが、次のように表示されることが一般的です：

#+begin_src lisp
(defun name varlist &rest body)
#+end_src

新しい要素を入力するたびにこのメッセージは消えますが、スペースを入力するたびに再び表示されます。ファイルに定義を入力するとき、パラメータリストの後に定義を2行に分けることもできます。Returnキーを押してからTabキーを押すと、SLIMEが2行目を自動的に適切にインデントします。たとえば、このようになります：

#+begin_src lisp
(defun hello-world ()
  (format t "hello, world"))
#+end_src

SLIMEは括弧を対応させるのも手助けしてくれます。閉じ括弧を入力すると、対応する開き括弧が点滅します。あるいは、C-c C-qと入力してslime-close-parens-at-pointコマンドを呼び出すと、すべての開き括弧に対応する閉じ括弧を自動的に挿入できます。

この定義をLisp環境に取り込む方法は複数あります。最も簡単なのは、DEFUNフォームの中または直後にカーソルを置き、C-c C-cを押すことです。これで、slime-compile-defunコマンドが実行され、定義がLispに送信されて評価・コンパイルされます。これが機能しているか確認するために、hello-worldにいくつか変更を加え、再コンパイルしてから、C-c C-zまたはC-x bを使用してREPLに戻り、新しいバージョンを実行してみます。たとえば、次のように少し文法的に修正します：

#+begin_src lisp
(defun hello-world ()
  (format t "Hello, world!"))
#+end_src

次に、C-c C-cで再コンパイルし、C-c C-zを押してREPLに切り替えて新しいバージョンを試してみます。

#+begin_src lisp
CL-USER> (hello-world)
Hello, world!
NIL
#+end_src

作業していたファイルも保存したくなるでしょう。hello.lispバッファでC-x C-sを入力してEmacsコマンドsave-bufferを実行します。

ソースファイルからこの関数を再読み込みするために、まずLispを終了して再起動する必要があります。終了するには、SLIMEのショートカットを使用します。REPLでコンマ（,）を入力します。Emacsのウィンドウの下部にコマンドを求めるプロンプトが表示されます。そこでquit（またはsayoonara）と入力してEnterを押します。これでLispが終了し、SLIMEによって作成されたすべてのバッファ（REPLバッファなど）が閉じられます。次に、M-x slimeと入力してSLIMEを再起動します。

ためしにhello-worldを呼び出してみます。

#+begin_src lisp
CL-USER> (hello-world)
#+end_src

その時点で、SLIMEは新しいバッファを開き、次のようなものが表示されます：

#+begin_src lisp
attempt to call `HELLO-WORLD' which is an undefined function.
   [Condition of type UNDEFINED-FUNCTION]

Restarts:
  0: [TRY-AGAIN] Try calling HELLO-WORLD again.
  1: [RETURN-VALUE] Return a value instead of calling HELLO-WORLD.
  2: [USE-VALUE] Try calling a function other than HELLO-WORLD.
  3: [STORE-VALUE] Setf the symbol-function of HELLO-WORLD and call it again.
  4: [ABORT] Abort handling SLIME request.
  5: [ABORT] Abort entirely from this process.
#+end_src

バックトレース：
#+begin_src lisp
  0: (SWANK::DEBUG-IN-EMACS #<UNDEFINED-FUNCTION @ #x716b082a>)
  1: ((FLET SWANK:SWANK-DEBUGGER-HOOK SWANK::DEBUG-IT))
  2: (SWANK:SWANK-DEBUGGER-HOOK #<UNDEFINED-FUNCTION @ #x716b082a> #<Function SWANK-DEBUGGER-HOOK>)
  3: (ERROR #<UNDEFINED-FUNCTION @ #x716b082a>)
  4: (EVAL (HELLO-WORLD))
  5: (SWANK::EVAL-REGION "(hello-world)
" T)
#+end_src

むむっ！何が起こったのでしょうか？定義されていない関数を呼び出そうとしたためです。しかし、大量の出力にもかかわらず、Lispは実際にはこの状況をうまく処理しています。JavaやPythonとは異なり、Common Lispは単に例外を投げてスタックを巻き戻すわけではありません。また、存在しない関数を呼び出しただけでコアダンプを行うこともありません。その代わりにLispはデバッガにドロップします。

デバッガ内ではLispに完全にアクセスでき、プログラムの状態を調べたり、問題を修正したりすることができます。今はそのことを気にせず、単にqを入力してデバッガを終了し、REPLに戻ります。デバッガのバッファは消え、REPLは次のように表示されます：

#+begin_src lisp
CL-USER> (hello-world)
; Evaluation aborted
CL-USER>
#+end_src

デバッガから抜けてREPLに戻るためには、常にqを入力することができることを覚えておいてください。

REPLに戻ったら、再試行できます。問題が発生したのは、Lispがhello-worldの定義を知らなかったためです。そこで、保存したファイルhello.lisp内の定義をLispに知らせる必要があります。いくつか方法があります。バッファに戻って（C-x bを入力し、プロンプトにhello.lispと入力します）、先ほど行ったようにC-c C-cで再コンパイルするか、REPLでLOAD関数を使ってファイル全体をロードする方法もあります。これはファイルに複数の定義が含まれている場合には便利です。次のようにREPLでLOADを使います：
#+begin_src lisp
CL-USER> (load "hello.lisp")
; Loading /home/peter/my-lisp-programs/hello.lisp
T
#+end_src

Tはすべてが正常にロードされたことを意味します。LOADでファイルをロードすることは、ファイル内の各式を順番にREPLで入力することとほぼ同じです。したがって、LOADの呼び出し後にはhello-worldが定義されているはずです：

#+begin_src lisp
CL-USER> (hello-world)
Hello, world!
NIL
#+end_src

別の方法として、ファイルをまずCOMPILE-FILEでコンパイルし、次に結果として得られるFASLファイル（fast-loadファイル）をLOADすることもできます。COMPILE-FILEはFASLファイルの名前を返すので、次のようにREPLからコンパイルしてロードすることができます：

#+begin_src lisp
CL-USER> (load (compile-file "hello.lisp"))
;;; Compiling file hello.lisp
;;; Writing fasl file hello.fasl
;;; Fasl write complete
; Fast loading /home/peter/my-lisp-programs/hello.fasl
T
#+end_src

SLIMEも、REPLを使わずにファイルをロード・コンパイルするサポートを提供しています。ソースコードのバッファ内では、C-c C-lを押してslime-load-fileでファイルをロードできます。Emacsはロードするファイルの名前を尋ねますが、現在のファイルの名前が既に入力されているので、そのままEnterを押すことができます。または、C-c C-kを押して、現在のバッファに対応するファイルをコンパイルしてロードできます。Common Lispの一部の実装では、この方法でコードをコンパイルすると速度が大幅に向上しますが、他の実装では常にすべてをコンパイルするため、速度はあまり変わりません。

これで、Lispプログラミングの流れがつかめたと思います。もちろん、すべての技術やトリックを網羅したわけではありませんが、基本的な要素は見てきました。REPLとの対話、コードのロードとテスト、新しいコードの微調整とデバッグがその一部です。多くのLispプログラマは、プログラムを断続的に追加し、再定義し、テストしながら、数日間Lispイメージを動作させ続けます。

また、Lispアプリがデプロイされた後でも、REPLにアクセスできる方法が残っていることが多いです。Chapter 26では、Webサーバを稼働させながら、REPLとSLIMEを使ってLispと対話する方法を紹介します。さらには、SLIMEを使って異なるマシン上のLispに接続し、ローカルと同じようにリモートサーバをデバッグすることも可能です。

さらに印象的なリモートデバッグの例として、NASAの1998年のDeep Space 1ミッションがあります。宇宙船が打ち上げられて半年後、あるLispコードが2日間宇宙船を制御し、実験を行うことになっていました。残念ながら、地上テストでは見逃された微妙なレースコンディションが既に宇宙で発生していました。バグが宇宙--地球から1億マイル離れた場所--で発生した際、チームは実行中のコードを診断して修正することができ、実験を完了させることができました。14 あるプログラマは次のように述べています：

#+begin_quote
100億ドルのハードウェアで、1億マイル離れた場所で実行されているプログラムのデバッグは、興味深い経験です。宇宙船上で実行されているread-eval-printループが、問題の発見と修正に非常に役立ちました。
#+end_quote

まだLispコードを宇宙に送る準備は整っていませんが、次の章では、「hello, world」よりも少し興味深いプログラムを書いてみましょう。






